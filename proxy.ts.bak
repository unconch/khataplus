import { authMiddleware } from "@descope/nextjs-sdk/server"
import { NextResponse, NextRequest } from "next/server"

export default async function proxy(req: NextRequest) {
    const url = req.nextUrl
    const hostname = req.headers.get("host") || ""

    // 1. Subdomain / Tenant Detection
    const searchParams = url.searchParams.toString()
    const path = `${url.pathname}${searchParams.length > 0 ? `?${searchParams}` : ""}`

    // Define patterns to ignore (root domains)
    const rootDomains = ["localhost:3000", "khataplus.com", "www.khataplus.com", "khataplus.vercel.app"]

    let tenantSlug = null
    const isIp = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(:\d+)?$/.test(hostname)

    if (!rootDomains.includes(hostname) && !isIp) {
        // Extract subdomain (e.g., apple.localhost:3000 => apple)
        const parts = hostname.split('.')
        if (parts.length >= 2) {
            tenantSlug = parts[0]
        }
    }

    // 2. Geoblocking Logic
    const country = (req as any).geo?.country || "IN"
    const isIndia = country === "IN"

    if (!isIndia && url.pathname !== "/" && url.pathname !== "/geoblocked") {
        return NextResponse.redirect(new URL("/geoblocked", req.url))
    }

    // Inject path for layout detection (Critical for Demo/Guest mode)
    const requestHeaders = new Headers(req.headers)
    requestHeaders.set("x-invoke-path", url.pathname)

    // Create a new request with the updated headers validation
    const newReq = new NextRequest(req.url, {
        headers: requestHeaders,
    })

    // 3. Auth Middleware & Header Injection
    // @ts-ignore - Dynamic middleware wrapping
    const response = await authMiddleware({
        projectId: process.env.NEXT_PUBLIC_DESCOPE_PROJECT_ID,
        publicRoutes: ["/", "/auth/login", "/auth/sign-up", "/api/debug-db", "/setup-organization", "/invite/:path*", "/geoblocked", "/api/sentry-tunnel", "/demo", "/demo/:path*", "/demo/dashboard", "/demo/dashboard/:path*"],
        redirectUrl: "/auth/login",
    })(newReq as any)

    if (response) {
        // If authMiddleware returned a response (like a redirect), we return it
        // but we still want to make sure our headers are there if it's a "next" response
        return response
    }

    // If no response from authMiddleware, we continue with our updated headers
    const finalResponse = NextResponse.next({
        request: {
            headers: requestHeaders,
        }
    })

    // Inject tenant slug into headers for server components (response side)
    if (tenantSlug) {
        finalResponse.headers.set("x-tenant-slug", tenantSlug)
    }

    // Also set on response headers just in case
    finalResponse.headers.set("x-invoke-path", url.pathname)

    return finalResponse
}

export const config = {
    matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
}
